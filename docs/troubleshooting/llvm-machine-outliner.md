# LLVM MachineOutliner Bug on RISC-V

## Summary

LLVM's MachineOutliner optimization generates incorrect code on RISC-V that
causes infinite loops. This affects any Rust code compiled with `-Copt-level=z`
(optimize for size).

**Discovered**: 2026-01-21 **Affects**: All RISC-V targets (spike, real
hardware, zkVM emulators)

## Background

### What is `-Copt-level=z`?

Rust's `-Copt-level` flag controls how aggressively the compiler optimizes code.
The available levels are:

| Level | Description                                        |
| ----- | -------------------------------------------------- |
| `0`   | No optimizations (fastest compile, largest binary) |
| `1`   | Basic optimizations                                |
| `2`   | Most optimizations (good balance)                  |
| `3`   | All optimizations including expensive ones         |
| `s`   | Optimize for binary size                           |
| `z`   | Optimize aggressively for binary size              |

The `z` level enables all size optimizations, including the MachineOutliner.

### What is the MachineOutliner?

The MachineOutliner is an LLVM optimization pass that reduces binary size by
identifying repeated instruction sequences and extracting them into shared
functions. For example:

```
// Before outlining (repeated code in multiple places)
function A:          function B:
  mov x1, x2           mov x1, x2
  add x3, x4           add x3, x4
  store x5             store x5
  ...                  ...

// After outlining (shared function)
function A:          function B:          OUTLINED_FUNCTION_1:
  call OUTLINED_1      call OUTLINED_1      mov x1, x2
  ...                  ...                  add x3, x4
                                            store x5
                                            ret
```

This can significantly reduce binary size in code with repeated patterns.

## Symptoms

- Program hangs indefinitely at seemingly random points
- No crash or error message
- Works correctly without `-Copt-level=z`
- Binary contains many `OUTLINED_FUNCTION_*` symbols

## Root Cause

On RISC-V, the MachineOutliner generates a faulty calling pattern:

### The Bug Pattern

```asm
# Caller code (generated by outliner)
auipc   t1, 0           # t1 = PC (address of this instruction)
jr      offset(t1)      # Jump to outlined function

# Outlined function
...                     # Function body
jr      t1              # Return to caller
```

### Why It Fails

1. `auipc t1, 0` sets `t1` to the address of the `auipc` instruction itself
2. The outlined function returns via `jr t1`
3. This jumps back to the `auipc` instruction, not the instruction after `jr`
4. The `auipc` executes again, setting `t1` to the same address
5. The cycle repeats infinitely

### Expected Behavior

The outliner should either:

- Use `t1` to store the return address (PC + 8, after the `jr`)
- Or use a different register for the call target

## Solution

Disable the MachineOutliner by adding this rustflag:

```
-Cllvm-args=-enable-machine-outliner=never
```

## Trade-offs

Disabling the outliner increases binary size. The outliner exists specifically
to reduce code size by factoring out common sequences. Depending on your binary:

- **Small increase**: If your code has few repeated sequences
- **Significant increase**: If your code has many similar functions (e.g.,
  generated code, macros that expand similarly)

If binary size is critical, consider:

1. Using `-Copt-level=s` instead of `-Copt-level=z` (less aggressive, may not
   trigger outliner)
2. Waiting for the LLVM bug to be fixed upstream
3. Using link-time optimization (LTO) for size reduction instead

## Related LLVM Issues

- [Bug #167381](https://github.com/llvm/llvm-project/issues/167381): Cannot
  relax `auipc` + `jr` after Machine Outliner
- [PR #127659](https://github.com/llvm/llvm-project/pull/127659): Fixed
  correctness bug in candidate analysis
- [PR #115867](https://github.com/llvm/llvm-project/pull/115867): Deprioritize
  X5 register to help outliner

## Technical Details

### RISC-V Calling Convention

The outliner is supposed to use `t0` (x5) as the return address register because
it's a caller-saved temporary. However, the code generation uses `t1` (x6) and
incorrectly calculates the return address.

### Affected LLVM Versions

This bug has been observed in:

- LLVM 17, 18, 19 (bundled with Rust 1.75+)
- rustc 1.83.0, 1.90.0 (confirmed)

## Reproduction

### Requirements

The MachineOutliner only triggers on **non-trivial codebases** with repeated
code patterns. A minimal "hello world" program will NOT trigger the bug because:

1. The outliner needs substantial repeated instruction sequences to extract
2. Small programs don't have enough code to benefit from outlining
3. The bug manifests only when outlined functions are actually generated

### Step 1: Build std-smoke with `-Copt-level=z`

Use `CARGO_ENCODED_RUSTFLAGS` environment variable to pass the flag:

```bash
CARGO_ENCODED_RUSTFLAGS="-Copt-level=z" cargo spike build -p std-smoke \
    --target "riscv64imac-zero-linux-musl" \
    --mode std \
    --backtrace=enable \
    -- --features=std,backtrace,with-spike --profile dev
```

> **Note:** `cargo spike build` merges `CARGO_ENCODED_RUSTFLAGS` with its
> internal flags, so user-provided rustflags are preserved.

### Step 2: Verify outlined functions were generated

```bash
nm target/riscv64imac-zero-linux-musl/debug/std-smoke | grep -c OUTLINED_FUNCTION
```

### Step 3: Run with cargo spike run - observe the hang

```bash
cargo spike run target/riscv64imac-zero-linux-musl/debug/std-smoke \
    --isa RV64IMAC \
    --instructions 5000000 \
    -l
```

## References

- [LLVM MachineOutliner documentation](https://llvm.org/docs/LinkTimeOptimization.html)
- [RISC-V Calling Convention](https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf)
- [Rust optimization levels](https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level)
