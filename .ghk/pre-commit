#!/usr/bin/env -S RUSTC_BOOTSTRAP=1 cargo -Zscript --quiet
---
[package]
edition = "2021"
[dependencies]
globset = "0.4"
log = "0.4"
env_logger = "0.11"
derive_builder = "0.20"
---

use derive_builder::Builder;
use std::os::unix::fs::PermissionsExt;
use std::{
    collections::{HashMap, HashSet, VecDeque},
    env,
    path::{Path, PathBuf},
    process::{Command, ExitStatus, Stdio},
    sync::OnceLock,
};

type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

// sh! command execution

/// Trait for types that can configure a `Command` before execution.
pub trait ShConfig {
    /// Apply configuration to the given `Command`.
    fn apply(&self, cmd: &mut Command);
}

// Allow using `&T` where `T: ShConfig`.
impl<T: ShConfig + ?Sized> ShConfig for &T {
    fn apply(&self, cmd: &mut Command) {
        (*self).apply(cmd)
    }
}

#[rustfmt::skip]
#[derive(Copy, Clone, Default)]
pub enum StreamMode { #[default] Inherit, Pipe, Null }

impl From<StreamMode> for Stdio {
    fn from(m: StreamMode) -> Self {
        match m {
            StreamMode::Inherit => Stdio::inherit(),
            StreamMode::Pipe => Stdio::piped(),
            StreamMode::Null => Stdio::null(),
        }
    }
}

#[derive(Clone, Default, Builder)]
#[builder(default)]
pub struct ShOptions {
    pub stdout: StreamMode,
    pub stderr: StreamMode,
    pub cwd: Option<PathBuf>,
    pub quiet: bool,
}

impl ShConfig for ShOptions {
    fn apply(&self, cmd: &mut Command) {
        cmd.stdout(Stdio::from(self.stdout))
            .stderr(Stdio::from(self.stderr));
        if let Some(dir) = &self.cwd {
            cmd.current_dir(dir);
        }
    }
}

pub struct ShOutput(pub ExitStatus, pub String, pub String);

static PIPE_OPTS: OnceLock<ShOptions> = OnceLock::new();

fn pipe_opts() -> &'static ShOptions {
    PIPE_OPTS.get_or_init(|| {
        let verbose = env::var("VERBOSE")
            .map(|v| v == "1" || v.to_lowercase() == "true")
            .unwrap_or(false);

        ShOptionsBuilder::default()
            .stdout(StreamMode::Pipe)
            .quiet(!verbose)
            .build()
            .unwrap()
    })
}

#[macro_export]
macro_rules! sh {
    // argv mode (options): program + bracketed args list
    (options($opts:expr), $prog:expr, [$($arg:expr),* $(,)?] $(,)?) => {{
        sh(
            ShCmd::Argv(
                std::ffi::OsString::from($prog),
                vec![$(std::ffi::OsString::from($arg)),*],
            ),
            $opts,
        )
    }};

    // argv mode (default options): program + bracketed args list
    ($prog:expr, [$($arg:expr),* $(,)?] $(,)?) => {{
        sh(
            ShCmd::Argv(
                std::ffi::OsString::from($prog),
                vec![$(std::ffi::OsString::from($arg)),*],
            ),
            ShOptions::default(),
        )
    }};

    // with options + arbitrary expression (already a String/&str)
    (options($opts:expr), $cmd:expr) => {{
        let cmd = $cmd.to_string();
        sh(ShCmd::Script(cmd), $opts)
    }};

    // without options + arbitrary expression
    ($cmd:expr) => {{
        let cmd = $cmd.to_string();
        sh(ShCmd::Script(cmd), ShOptions::default())
    }};
}

enum ShCmd {
    Script(String),
    Argv(std::ffi::OsString, Vec<std::ffi::OsString>),
}

fn sh(cmd: ShCmd, opts: ShOptions) -> Result<ShOutput> {
    fn exec(
        mut c: Command,
        opts: &ShOptions,
        desc: &str,
        cleanup: Option<&Path>,
    ) -> Result<ShOutput> {
        opts.apply(&mut c);
        let output = match c.output() {
            Ok(o) => o,
            Err(e) => {
                if let Some(p) = cleanup {
                    let _ = std::fs::remove_file(p);
                }

                return Err(format!("Failed to execute command: {}\nError: {}", desc, e).into());
            }
        };
        if let Some(p) = cleanup {
            let _ = std::fs::remove_file(p);
        }

        let stdout = String::from_utf8_lossy(&output.stdout).into_owned();
        let stderr = String::from_utf8_lossy(&output.stderr).into_owned();

        if !output.status.success() {
            return Err(format!(
                "Command failed with exit code {:?}: {}\nStderr: {}",
                output.status.code(),
                desc,
                stderr
            )
            .into());
        }
        Ok(ShOutput(output.status, stdout, stderr))
    }

    fn build_argv(program: &std::ffi::OsString, args: &[std::ffi::OsString]) -> (Command, String) {
        let mut c = Command::new(program);
        c.args(args);
        let desc = format!("(argv) {:?} {:?}", program, args);
        (c, desc)
    }

    fn build_script(cmd: &str) -> Result<(Command, String, Option<std::path::PathBuf>)> {
        let cmd_trim = cmd.trim_start();
        if cmd_trim.starts_with("#!") {
            let path = std::env::temp_dir().join(format!(
                "zk-pre-commit-{}-{}.tmp",
                std::process::id(),
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_nanos()
            ));
            std::fs::write(&path, cmd_trim)?;
            std::fs::set_permissions(&path, std::fs::Permissions::from_mode(0o700))?;
            Ok((Command::new(&path), cmd_trim.to_string(), Some(path)))
        } else {
            let mut c = Command::new("sh");
            // Important: don't trim in the `sh -c` path; it can change shell script semantics.
            c.arg("-c").arg(cmd);
            Ok((c, cmd_trim.to_string(), None))
        }
    }

    match cmd {
        ShCmd::Argv(program, args) => {
            if !opts.quiet {
                log::debug!("[sh] (argv) {:?} {:?}", program, args);
            }
            let (c, desc) = build_argv(&program, &args);
            exec(c, &opts, &desc, None)
        }
        ShCmd::Script(cmd) => {
            let (c, desc, cleanup) = build_script(&cmd)?;
            if !opts.quiet {
                log::debug!("[sh] {}", desc);
            }
            exec(c, &opts, &desc, cleanup.as_deref())
        }
    }
}
// file types

struct FileTypeRule {
    lang: &'static str,
    exts: &'static [&'static str],
    names: &'static [&'static str],
    shebang: &'static [&'static str],
    modeline: &'static [&'static str],
}

macro_rules! file_types {
    ($($lang:ident => { exts: [$($ext:expr),* $(,)?], names: [$($name:expr),* $(,)?], shebang: [$($she:expr),* $(,)?], modeline: [$($mode:expr),* $(,)?], },)*) => {
        static FILE_TYPE_RULES: &[FileTypeRule] = &[$(
            FileTypeRule { lang: stringify!($lang), exts: &[$($ext),*], names: &[$($name),*], shebang: &[$($she),*], modeline: &[$($mode),*] }
        ),*];
    }
}

file_types! {
    rust => { exts: ["rs"], names: [], shebang: ["rust","cargo"], modeline: ["mode: rust","ft=rust"], },
    shell => { exts: ["sh","bash","zsh"], names: [], shebang: ["bash","sh","zsh"], modeline: ["mode: sh","ft=sh"], },
}

fn detect_file_type(path: &Path) -> Option<&'static str> {
    let filename = path.file_name()?.to_str()?;
    let ext = path.extension().and_then(|e| e.to_str());
    if let Some(lang) = FILE_TYPE_RULES
        .iter()
        .find(|r| ext.map_or(false, |e| r.exts.contains(&e)) || r.names.contains(&filename))
        .map(|r| r.lang)
    {
        return Some(lang);
    }

    std::fs::read_to_string(path).ok().and_then(|content| {
        let lines: Vec<_> = content.lines().collect();
        let mut scan = lines.iter().take(5).chain(lines.iter().rev().take(5));
        scan.find_map(|line| {
            FILE_TYPE_RULES.iter().find_map(|r| {
                (r.shebang
                    .iter()
                    .any(|s| line.starts_with("#!") && line.contains(s))
                    || r.modeline.iter().any(|m| line.contains(m)))
                .then_some(r.lang)
            })
        })
    })
}

// filter! macro

use globset::{Glob, GlobSetBuilder};

fn is_no_ext(path: &Path) -> bool {
    path.file_name()
        .and_then(|s| s.to_str())
        .map(|s| !s.contains('.'))
        .unwrap_or(false)
}

macro_rules! filter {
    ($files:expr, ["*"]) => {{
        $files
            .iter()
            .filter(|f| is_no_ext(f))
            .cloned()
            .collect::<Vec<_>>()
    }};

    ($files:expr, [$($pat:expr),* $(,)?]) => {{
        let mut builder = GlobSetBuilder::new();
        $(
            builder.add(Glob::new($pat).expect("invalid glob pattern"));
        )*
        let set = builder.build().expect("failed to build globset");

        $files
            .iter()
            .filter(|f| {
                let path_str = f.to_string_lossy();
                set.is_match(path_str.as_ref())
            })
            .cloned()
            .collect::<Vec<_>>()
    }};
}

fn collect_files<'a>(files: &'a [PathBuf], patterns: &[&str], detected_lang: &str) -> Vec<PathBuf> {
    let mut out = Vec::new();

    // 1. Add files matching patterns
    for p in patterns {
        out.extend(filter!(files, [p]));
    }

    // 2. Add extension-less files detected by language
    for f in filter!(files, ["*"]) {
        if f.extension().is_none() && detect_file_type(&f) == Some(detected_lang) {
            out.push(f);
        }
    }

    // 3. Deduplicate
    out.sort();
    out.dedup();

    out
}
// filesystem helpers

struct Context {
    root: PathBuf,
}

impl Context {
    fn new() -> Result<Self> {
        let output = sh!(
            options(pipe_opts().clone()),
            "git rev-parse --show-toplevel"
        )?;
        let root = PathBuf::from(output.1.trim());
        Ok(Context { root })
    }
}

fn find_upwards_bounded(start: &Path, patterns: &[&str], stop_at: &Path) -> Option<PathBuf> {
    let mut dir = if start.is_dir() {
        start.to_path_buf()
    } else {
        start.parent().unwrap_or(start).to_path_buf()
    };

    loop {
        for pat in patterns {
            let candidate = dir.join(pat);
            if candidate.exists() {
                return Some(candidate);
            }
        }

        if dir == stop_at {
            break;
        }

        if !dir.pop() {
            break;
        }
    }

    None
}

// task system

fn restage_file(file: &Path) -> Result<()> {
    if !file.exists() {
        return Ok(());
    }
    sh!("git", ["add", "--", file.as_os_str()])?;
    Ok(())
}

trait Task {
    fn name(&self) -> &'static str;
    fn depends_on(&self) -> &'static [&'static str];
    fn run(&self, ctx: &Context, files: &[PathBuf]) -> Result<Vec<PathBuf>>;
}

macro_rules! define_task {
    ($type:ident,
     name = $name:expr,
     depends_on = [$($dep:expr),* $(,)?],
     run = $run:expr
    ) => {
        struct $type;

        impl Task for $type {
            fn name(&self) -> &'static str { $name }
            fn depends_on(&self) -> &'static [&'static str] {
                &[$($dep),*]
            }
            fn run(&self, ctx: &Context, files: &[PathBuf]) -> Result<Vec<PathBuf>> {
                ($run)(ctx, files)
            }
        }

        impl Default for $type {
            fn default() -> Self { Self }
        }
    };
}

macro_rules! fmt_task {
    ($type:ident,
     $name:expr,
     patterns = [$($pat:expr),*],
     lang = $lang:expr,
     run = $action:expr $(,)?
    ) => {
        define_task!(
            $type,
            name = $name,
            depends_on = [],
            run = |_ctx: &Context, files: &[PathBuf]| {
                let targets = collect_files(files, &[$($pat),*], $lang)
                    .into_iter()
                    .filter(|f| f.exists())
                    .collect::<Vec<_>>();
                let action = $action;
                for f in &targets {
                    let _ = action(f)?;
                }
                Ok(targets)
            }
        );
    };
}

// Helper to extract packages from changed files
fn extract_matrix_packages(ctx: &Context, files: &[PathBuf]) -> Vec<String> {
    let interesting = filter!(files, ["*.rs", "Cargo.toml"]);

    let manifests: HashSet<PathBuf> = interesting
        .iter()
        .filter_map(|f| find_upwards_bounded(f, &["Cargo.toml"], &ctx.root))
        .map(|m| if m.is_absolute() { m } else { ctx.root.join(m) })
        .collect();

    let mut packages: Vec<String> = manifests
        .iter()
        .filter_map(|m| package_name_from_manifest(m))
        .collect();
    packages.sort();
    packages.dedup();

    packages
        .into_iter()
        .filter(|p| matrix_has_package(ctx, p))
        .collect()
}

// Rust tasks
define_task!(
    RustFixTask,
    name = "rust_fix",
    depends_on = [],
    run = |ctx: &Context, files: &[PathBuf]| {
        let interesting = filter!(files, ["*.rs", "Cargo.toml"]);
        let filtered = extract_matrix_packages(ctx, files);

        if filtered.is_empty() {
            return Ok(interesting);
        }

        let mut argv: Vec<std::ffi::OsString> = vec![
            "run".into(),
            "-q".into(),
            "-p".into(),
            "xtask".into(),
            "--".into(),
            "matrix".into(),
        ];
        for p in &filtered {
            argv.push("-p".into());
            argv.push(p.into());
        }
        argv.push("--command".into());
        argv.push("fix".into());

        let mut opts = pipe_opts().clone();
        opts.cwd = Some(ctx.root.clone());
        sh(ShCmd::Argv("cargo".into(), argv), opts)?;

        Ok(interesting)
    }
);

define_task!(
    RustClippyTask,
    name = "rust_clippy",
    depends_on = ["rust_fix"],
    run = |ctx: &Context, files: &[PathBuf]| {
        let interesting = filter!(files, ["*.rs", "Cargo.toml"]);
        let filtered = extract_matrix_packages(ctx, files);

        if filtered.is_empty() {
            return Ok(interesting);
        }

        let mut argv: Vec<std::ffi::OsString> = vec![
            "run".into(),
            "-q".into(),
            "-p".into(),
            "xtask".into(),
            "--".into(),
            "matrix".into(),
        ];
        for p in &filtered {
            argv.push("-p".into());
            argv.push(p.into());
        }
        argv.push("--command".into());
        argv.push("clippy".into());

        let mut opts = pipe_opts().clone();
        opts.cwd = Some(ctx.root.clone());
        sh(ShCmd::Argv("cargo".into(), argv), opts)?;

        Ok(interesting)
    }
);

define_task!(
    RustCheckTask,
    name = "rust_check",
    depends_on = ["rust_clippy"],
    run = |ctx: &Context, files: &[PathBuf]| {
        let interesting = filter!(files, ["*.rs", "Cargo.toml"]);
        let filtered = extract_matrix_packages(ctx, files);

        if filtered.is_empty() {
            return Ok(interesting);
        }

        let mut argv: Vec<std::ffi::OsString> = vec![
            "run".into(),
            "-q".into(),
            "-p".into(),
            "xtask".into(),
            "--".into(),
            "matrix".into(),
        ];
        for p in &filtered {
            argv.push("-p".into());
            argv.push(p.into());
        }
        argv.push("--command".into());
        argv.push("check".into());

        let mut opts = pipe_opts().clone();
        opts.cwd = Some(ctx.root.clone());
        sh(ShCmd::Argv("cargo".into(), argv), opts)?;

        Ok(interesting)
    }
);

define_task!(
    RustCheckWorkspace,
    name = "rust_check_workspace",
    depends_on = [],
    run = |ctx: &Context, files: &[PathBuf]| {
        let interesting = filter!(files, ["*.rs", "Cargo.toml", "release-plz.toml"]);

        if interesting.is_empty() {
            return Ok(interesting);
        }

        let argv: Vec<std::ffi::OsString> = vec![
            "run".into(),
            "-q".into(),
            "-p".into(),
            "xtask".into(),
            "--".into(),
            "check-workspace".into(),
        ];

        let mut opts = pipe_opts().clone();
        opts.cwd = Some(ctx.root.clone());
        sh(ShCmd::Argv("cargo".into(), argv), opts)?;

        Ok(interesting)
    }
);

fmt_task!(
    RustFmtTask,
    "rust_fmt",
    patterns = ["*.rs"],
    lang = "rust",
    run = |f: &PathBuf| sh!("rustfmt", [f.as_os_str()]),
);
fmt_task!(
    ShellFmtTask,
    "shell_fmt",
    patterns = ["*.sh"],
    lang = "shell",
    run = |f: &PathBuf| sh!("shfmt", ["-w", f.as_os_str()]),
);
fmt_task!(
    TomlFmtTask,
    "toml_fmt",
    patterns = ["*.toml"],
    lang = "toml",
    run = |f: &PathBuf| sh!("taplo", ["format", f.as_os_str()]),
);
fmt_task!(
    DenoFmtTask,
    "deno_fmt",
    patterns = [
        "*.json", "*.yaml", "*.yml", "*.md", "*.jsonc", "*.ts", "*.mjs", "*.js", "*.cjs", "*.tsx",
        "*.jsx", "*.html", "*.css", "*.scss", "*.mdx"
    ],
    lang = "deno",
    run = |f: &PathBuf| sh!("deno", ["fmt", f.as_os_str()]),
);

fn main() {
    env_logger::Builder::from_default_env()
        .format(|buf, record| {
            use std::io::Write;
            writeln!(buf, "[{}] {}", record.target(), record.args())
        })
        .init();

    // Expand PATH to include common tool installation locations
    if let (Ok(current_path), Ok(home)) = (env::var("PATH"), env::var("HOME")) {
        let extra_paths = vec![
            format!("{}/.deno/bin", home),
            format!("{}/.cargo/bin", home),
            format!("{}/go/bin", home),
            format!("{}/.local/bin", home),
        ];
        let expanded_path = format!("{}:{}", extra_paths.join(":"), current_path);
        env::set_var("PATH", expanded_path);
    }

    if let Err(e) = run() {
        log::error!("[pre-commit] error: {e}");
        std::process::exit(1);
    }

    println!("[pre-commit] all tasks completed successfully!");
    std::process::exit(0);
}

fn run() -> Result<()> {
    let mut mode: Option<FilesMode> = None;
    let mut files: Vec<PathBuf> = Vec::new();
    for arg in env::args().skip(1) {
        match arg.as_str() {
            "--staged" => {
                if mode == Some(FilesMode::Dirty) {
                    return Err("--dirty and --staged are mutually exclusive".into());
                }
                mode = Some(FilesMode::Staged);
            }
            "--dirty" => {
                if mode == Some(FilesMode::Staged) {
                    return Err("--dirty and --staged are mutually exclusive".into());
                }
                mode = Some(FilesMode::Dirty);
            }
            _ => files.push(PathBuf::from(arg)),
        }
    }
    let mode = mode.unwrap_or(FilesMode::Staged);

    if files.is_empty() {
        files = match mode {
            FilesMode::Staged => staged_paths()?,
            FilesMode::Dirty => dirty_paths()?,
        };
        if files.is_empty() {
            println!(
                "[pre-commit] no {} files to check, skipping.",
                match mode {
                    FilesMode::Staged => "staged",
                    FilesMode::Dirty => "dirty",
                }
            );
            return Ok(());
        }
    }

    let ctx = Context::new()?;

    // Only hide+restore unstaged changes for files that are staged.
    // In --dirty mode, we intentionally do NOT modify working tree state.
    let unstaged_in_staged: Vec<PathBuf> = if mode == FilesMode::Staged {
        let unstaged = unstaged_paths()?;
        files
            .iter()
            .filter(|p| unstaged.contains(*p))
            .cloned()
            .collect()
    } else {
        Vec::new()
    };
    let unstaged_patch = if mode == FilesMode::Staged {
        hide_unstaged_changes_for_staged_files(&ctx, &unstaged_in_staged)?
    } else {
        None
    };

    let tasks: Vec<Box<dyn Task>> = vec![
        Box::new(RustCheckWorkspace::default()),
        Box::new(RustFixTask::default()),
        Box::new(RustClippyTask::default()),
        Box::new(RustCheckTask::default()),
        Box::new(RustFmtTask::default()),
        Box::new(ShellFmtTask::default()),
        Box::new(TomlFmtTask::default()),
        Box::new(DenoFmtTask::default()),
    ];

    let task_result: Result<Vec<PathBuf>> =
        run_tasks(tasks, &ctx, &files, mode == FilesMode::Staged);

    if let Ok(processed_files) = &task_result {
        if !processed_files.is_empty() {
            println!("[pre-commit] processed {} files:", processed_files.len());
            for file in processed_files {
                println!("  {}", file.display());
            }
        }
    }

    let restore_result: Result<()> = if let Some(patch) = unstaged_patch.as_deref() {
        restore_unstaged_changes_for_staged_files(&ctx, patch, &unstaged_in_staged)
    } else {
        Ok(())
    };

    match (task_result.map(|_| ()), restore_result) {
        (Ok(()), Ok(())) => Ok(()),
        (Err(e), Ok(())) => Err(e),
        (Ok(()), Err(e)) => Err(e),
        (Err(task_err), Err(restore_err)) => Err(format!(
            "tasks failed: {task_err}; additionally failed to restore unstaged changes: {restore_err}"
        )
        .into()),
    }
}

// task runner
fn run_tasks(
    tasks: Vec<Box<dyn Task>>,
    ctx: &Context,
    files: &[PathBuf],
    restage: bool,
) -> Result<Vec<PathBuf>> {
    let mut name_to_index = HashMap::new();
    for (i, t) in tasks.iter().enumerate() {
        if name_to_index.insert(t.name(), i).is_some() {
            return Err(format!("duplicate task name: {}", t.name()).into());
        }
    }

    let mut indegree = HashMap::<&'static str, usize>::new();
    let mut graph = HashMap::<&'static str, Vec<&'static str>>::new();

    for t in &tasks {
        let name = t.name();
        indegree.entry(name).or_insert(0);

        for dep in t.depends_on() {
            if !name_to_index.contains_key(dep) {
                return Err(format!("task '{}' depends on unknown '{}'", name, dep).into());
            }
            indegree.entry(name).and_modify(|c| *c += 1);
            graph.entry(dep).or_default().push(name);
        }
    }

    let mut queue: VecDeque<&'static str> = indegree
        .iter()
        .filter_map(|(&name, &deg)| (deg == 0).then_some(name))
        .collect();
    queue.make_contiguous().sort_unstable();

    for neighbors in graph.values_mut() {
        neighbors.sort_unstable();
        neighbors.dedup();
    }

    let mut ordered = Vec::new();
    while let Some(name) = queue.pop_front() {
        ordered.push(name);
        if let Some(neighbors) = graph.get(name) {
            for &n in neighbors {
                let e = indegree.get_mut(n).unwrap();
                *e -= 1;
                if *e == 0 {
                    queue.push_back(n);
                }
            }
        }
    }

    if ordered.len() != tasks.len() {
        return Err("cycle detected in task dependencies".into());
    }

    let mut all_processed_files = Vec::new();
    for name in ordered {
        let idx = name_to_index[name];
        let t = &tasks[idx];
        log::debug!("[task] {}", t.name());
        let processed_files = t.run(ctx, files)?;
        for file in processed_files {
            if !all_processed_files.contains(&file) {
                all_processed_files.push(file);
            }
        }
    }

    if restage {
        for file in &all_processed_files {
            restage_file(file)?;
        }
    }

    Ok(all_processed_files)
}

fn capture(cmd: &str) -> Result<String> {
    Ok(sh!(options(pipe_opts().clone()), cmd)?.1)
}

fn capture_in(cwd: &Path, cmd: &str) -> Result<String> {
    let mut opts = pipe_opts().clone();
    opts.cwd = Some(cwd.to_path_buf());
    Ok(sh(ShCmd::Script(cmd.to_string()), opts)?.1)
}

fn parse_nul_paths(out: &str) -> Vec<PathBuf> {
    out.split('\0')
        .filter(|s| !s.is_empty())
        .map(PathBuf::from)
        .collect()
}

fn join_paths(paths: &[PathBuf]) -> String {
    paths
        .iter()
        .map(|p| p.display().to_string())
        .collect::<Vec<_>>()
        .join(", ")
}

fn package_name_from_manifest(manifest_path: &Path) -> Option<String> {
    let s = std::fs::read_to_string(manifest_path).ok()?;
    let mut in_package = false;
    for line in s.lines() {
        let line = line.trim();
        if line.starts_with('[') && line.ends_with(']') {
            in_package = line == "[package]";
            continue;
        }
        if !in_package {
            continue;
        }
        if let Some(rest) = line.strip_prefix("name") {
            let rest = rest.trim_start();
            if let Some(rest) = rest.strip_prefix('=') {
                let rest = rest.trim();
                if let Some(stripped) = rest.strip_prefix('"').and_then(|r| r.strip_suffix('"')) {
                    return Some(stripped.to_string());
                }
            }
        }
    }
    None
}

fn matrix_has_package(ctx: &Context, package: &str) -> bool {
    let path = ctx.root.join("matrix.yaml");
    if !path.exists() {
        return false;
    }
    let s = match std::fs::read_to_string(&path) {
        Ok(s) => s,
        Err(_) => return false,
    };

    let needle = format!("package: {}", package);
    s.lines().any(|l| l.trim() == needle)
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum FilesMode {
    Staged,
    Dirty,
}

fn dirty_paths() -> Result<Vec<PathBuf>> {
    let mut out = Vec::new();
    // Unstaged modifications (but not staged).
    out.extend(parse_nul_paths(&capture("git diff --name-only -z")?));
    // Untracked files.
    out.extend(parse_nul_paths(&capture(
        "git ls-files --others --exclude-standard -z",
    )?));
    out.sort();
    out.dedup();
    Ok(out)
}

fn unstaged_paths() -> Result<Vec<PathBuf>> {
    Ok(parse_nul_paths(&capture("git diff --name-only -z")?))
}

fn staged_paths() -> Result<Vec<PathBuf>> {
    Ok(parse_nul_paths(&capture(
        "git diff --cached --name-only -z",
    )?))
}

fn git_dir(ctx: &Context) -> Result<PathBuf> {
    let out = capture_in(&ctx.root, "git rev-parse --git-dir")?;
    let p = PathBuf::from(out.trim());
    Ok(if p.is_absolute() { p } else { ctx.root.join(p) })
}

fn hide_unstaged_changes_for_staged_files(
    ctx: &Context,
    paths: &[PathBuf],
) -> Result<Option<PathBuf>> {
    if paths.is_empty() {
        return Ok(None);
    }

    let git_dir = git_dir(ctx)?;
    let patch = git_dir.join(format!(
        "zk-pre-commit-unstaged-{}-{}.patch",
        std::process::id(),
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos()
    ));

    // Save unstaged changes for these staged files into a patch inside `.git/`,
    // then force-checkout the working tree back to the staged version.
    let mut diff_argv: Vec<std::ffi::OsString> = vec![
        "diff".into(),
        "--binary".into(),
        "--unified=0".into(),
        "--no-color".into(),
        "--no-ext-diff".into(),
        "--patch".into(),
        "--output".into(),
        patch.as_os_str().into(),
        "--".into(),
    ];
    diff_argv.extend(paths.iter().map(|p| p.as_os_str().into()));

    let mut opts = pipe_opts().clone();
    opts.cwd = Some(ctx.root.clone());
    sh(ShCmd::Argv("git".into(), diff_argv), opts.clone())?;

    let mut checkout_argv: Vec<std::ffi::OsString> =
        vec!["checkout".into(), "--force".into(), "--".into()];
    checkout_argv.extend(paths.iter().map(|p| p.as_os_str().into()));
    sh(ShCmd::Argv("git".into(), checkout_argv), opts)?;

    Ok(Some(patch))
}

fn restore_unstaged_changes_for_staged_files(
    ctx: &Context,
    patch: &Path,
    paths: &[PathBuf],
) -> Result<()> {
    let mut opts = pipe_opts().clone();
    opts.cwd = Some(ctx.root.clone());

    let apply = |extra: &[&str]| -> Result<()> {
        let mut argv: Vec<std::ffi::OsString> = vec![
            "apply".into(),
            "-v".into(),
            "--whitespace=nowarn".into(),
            "--recount".into(),
            "--unidiff-zero".into(),
        ];
        argv.extend(extra.iter().map(|s| (*s).into()));
        argv.push(patch.as_os_str().into());
        sh(ShCmd::Argv("git".into(), argv), opts.clone()).map(|_| ())
    };

    // Try a normal apply first, then retry with 3-way merge if it fails.
    match apply(&[]) {
        Ok(()) => {
            let _ = std::fs::remove_file(patch);
            Ok(())
        }
        Err(first_err) => match apply(&["--3way"]) {
            Ok(()) => {
                let _ = std::fs::remove_file(patch);
                Ok(())
            }
            Err(second_err) => {
                let files = join_paths(paths);
                Err(format!(
                    "{second_err}\n[pre-commit] failed to restore unstaged changes for staged files: {files}\n\
                     A patch with the unstaged changes was left at: {}\n\
                     Fix conflicts manually, then remove the patch file when done.\n\
                     (original apply error: {first_err})",
                    patch.display()
                )
                .into())
            }
        },
    }
}

// -*- mode: rust -*-
